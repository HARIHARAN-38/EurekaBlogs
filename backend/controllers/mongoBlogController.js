const { Blog, User, Comment } = require('../models/mongodb');

// Get all blogs with pagination
exports.getAllBlogs = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    const category = req.query.category;
    const status = req.query.status || 'published';
    
    let filter = { status };
    if (category) {
      filter.category = category;
    }

    const totalBlogs = await Blog.countDocuments(filter);
    
    const blogs = await Blog.find(filter)
      .skip(skip)
      .limit(limit)
      .populate('author', 'username profilePicture')
      .sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: blogs.length,
      totalBlogs,
      totalPages: Math.ceil(totalBlogs / limit),
      currentPage: page,
      blogs
    });
  } catch (error) {
    console.error('Error fetching blogs:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch blogs',
      error: error.message
    });
  }
};

// Get single blog by ID or slug
exports.getBlogByIdOrSlug = async (req, res) => {
  try {
    const { identifier } = req.params;
    let blog;

    // Check if identifier is a valid MongoDB ObjectId
    const isValidObjectId = /^[0-9a-fA-F]{24}$/.test(identifier);

    if (isValidObjectId) {
      blog = await Blog.findById(identifier)
        .populate('author', 'username profilePicture bio')
        .populate({
          path: 'comments',
          populate: {
            path: 'userId',
            select: 'username profilePicture',
            model: 'User'
          }
        });
    } else {
      blog = await Blog.findOne({ slug: identifier })
        .populate('author', 'username profilePicture bio')
        .populate({
          path: 'comments',
          populate: {
            path: 'userId',
            select: 'username profilePicture',
            model: 'User'
          }
        });
    }

    if (!blog) {
      return res.status(404).json({
        success: false,
        message: 'Blog not found'
      });
    }

    // Increment view count
    blog.viewCount += 1;
    await blog.save();

    res.status(200).json({
      success: true,
      blog
    });
  } catch (error) {
    console.error('Error fetching blog:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch blog',
      error: error.message
    });
  }
};

// Create a new blog
exports.createBlog = async (req, res) => {
  try {
    const { title, content, category, tags, coverImage, status, excerpt } = req.body;
    const authorId = req.user.id;  // From auth middleware

    // Validate required fields
    if (!title || !content) {
      return res.status(400).json({
        success: false,
        message: 'Title and content are required'
      });
    }

    // Create blog (slug will be auto-generated by pre-save hook)
    const blog = await Blog.create({
      title,
      content,
      excerpt: excerpt || content.substring(0, 200) + '...',
      category: category || 'general',
      tags: tags || [],
      coverImage,
      status: status || 'published',
      author: authorId
    });

    // Populate author info for response
    await blog.populate('author', 'username profilePicture');

    res.status(201).json({
      success: true,
      message: 'Blog created successfully',
      blog
    });
  } catch (error) {
    console.error('Error creating blog:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create blog',
      error: error.message
    });
  }
};

// Update a blog
exports.updateBlog = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, content, category, tags, coverImage, status, excerpt } = req.body;
    const userId = req.user.id;  // From auth middleware

    const blog = await Blog.findById(id);

    if (!blog) {
      return res.status(404).json({
        success: false,
        message: 'Blog not found'
      });
    }

    // Check if user is the author or an admin
    if (blog.author.toString() !== userId && req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to update this blog'
      });
    }

    // Update fields
    if (title) blog.title = title;
    if (content) blog.content = content;
    if (category) blog.category = category;
    if (tags) blog.tags = tags;
    if (coverImage) blog.coverImage = coverImage;
    if (status) blog.status = status;
    if (excerpt) blog.excerpt = excerpt;

    await blog.save();
    
    // Populate author info
    await blog.populate('author', 'username profilePicture');

    res.status(200).json({
      success: true,
      message: 'Blog updated successfully',
      blog
    });
  } catch (error) {
    console.error('Error updating blog:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update blog',
      error: error.message
    });
  }
};

// Delete a blog
exports.deleteBlog = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    const blog = await Blog.findById(id);

    if (!blog) {
      return res.status(404).json({
        success: false,
        message: 'Blog not found'
      });
    }

    // Check if user is the author or an admin
    if (blog.author.toString() !== userId && req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to delete this blog'
      });
    }

    await Blog.findByIdAndDelete(id);
    // Also delete related comments
    await Comment.deleteMany({ blogId: id });

    res.status(200).json({
      success: true,
      message: 'Blog deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting blog:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete blog',
      error: error.message
    });
  }
};

// Get blogs by category
exports.getBlogsByCategory = async (req, res) => {
  try {
    const { category } = req.params;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const totalBlogs = await Blog.countDocuments({ 
      category: category, 
      status: 'published' 
    });
    
    const blogs = await Blog.find({ category: category, status: 'published' })
      .skip(skip)
      .limit(limit)
      .populate('author', 'username profilePicture')
      .sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: blogs.length,
      totalBlogs,
      totalPages: Math.ceil(totalBlogs / limit),
      currentPage: page,
      blogs
    });
  } catch (error) {
    console.error('Error fetching blogs by category:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch blogs by category',
      error: error.message
    });
  }
};

// Get blogs by author
exports.getBlogsByAuthor = async (req, res) => {
  try {
    const { authorId } = req.params;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const totalBlogs = await Blog.countDocuments({ 
      author: authorId, 
      status: 'published' 
    });
    
    const blogs = await Blog.find({ author: authorId, status: 'published' })
      .skip(skip)
      .limit(limit)
      .populate('author', 'username profilePicture bio')
      .sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: blogs.length,
      totalBlogs,
      totalPages: Math.ceil(totalBlogs / limit),
      currentPage: page,
      blogs
    });
  } catch (error) {
    console.error('Error fetching blogs by author:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch blogs by author',
      error: error.message
    });
  }
};

// Search blogs
exports.searchBlogs = async (req, res) => {
  try {
    const { query } = req.query;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    if (!query) {
      return res.status(400).json({
        success: false,
        message: 'Search query is required'
      });
    }

    const searchFilter = {
      $or: [
        { title: { $regex: query, $options: 'i' } },
        { content: { $regex: query, $options: 'i' } },
        { tags: { $in: [new RegExp(query, 'i')] } }
      ],
      status: 'published'
    };

    const totalBlogs = await Blog.countDocuments(searchFilter);
    
    const blogs = await Blog.find(searchFilter)
      .skip(skip)
      .limit(limit)
      .populate('author', 'username profilePicture')
      .sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: blogs.length,
      totalBlogs,
      totalPages: Math.ceil(totalBlogs / limit),
      currentPage: page,
      blogs
    });
  } catch (error) {
    console.error('Error searching blogs:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to search blogs',
      error: error.message
    });
  }
};

// Get categories
exports.getCategories = async (req, res) => {
  try {
    const categories = await Blog.distinct('category');
    
    res.status(200).json({
      success: true,
      categories: categories.map(cat => ({
        _id: cat,
        name: cat
      }))
    });
  } catch (error) {
    console.error('Error fetching categories:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch categories',
      error: error.message
    });
  }
};

// Add comment to blog
exports.addComment = async (req, res) => {
  try {
    const { blogId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;

    if (!content) {
      return res.status(400).json({
        success: false,
        message: 'Comment content is required'
      });
    }

    const blog = await Blog.findById(blogId);
    if (!blog) {
      return res.status(404).json({
        success: false,
        message: 'Blog not found'
      });
    }

    const comment = await Comment.create({
      content,
      userId,
      blogId
    });

    await comment.populate('userId', 'username profilePicture');

    res.status(201).json({
      success: true,
      message: 'Comment added successfully',
      comment
    });
  } catch (error) {
    console.error('Error adding comment:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to add comment',
      error: error.message
    });
  }
};

// Get comments for a blog
exports.getComments = async (req, res) => {
  try {
    const { blogId } = req.params;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const blog = await Blog.findById(blogId);
    if (!blog) {
      return res.status(404).json({
        success: false,
        message: 'Blog not found'
      });
    }

    const totalComments = await Comment.countDocuments({ blogId });
    
    const comments = await Comment.find({ blogId })
      .skip(skip)
      .limit(limit)
      .populate('userId', 'username profilePicture')
      .sort({ createdAt: -1 });

    res.status(200).json({
      success: true,
      count: comments.length,
      totalComments,
      totalPages: Math.ceil(totalComments / limit),
      currentPage: page,
      comments
    });
  } catch (error) {
    console.error('Error fetching comments:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch comments',
      error: error.message
    });
  }
};
